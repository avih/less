#!/bin/sh

# enough cmd.exe for:
#  PATH=/to/self:$PATH make -f Makefile.wng [CC=..] REGEX_PACKAGE=regcomp-local
# set CMDDBG=1 (env) to enable logging to stderr
# set CMDNOMK=1 (env) to skip mk*.pl emulation (e.g. mkfuncs.pl)

strstr()  { ! case $1 in *"$2"*) false; esac; }  # only success/fail
echo()    { printf %s\\n "$*"; }
err()     { echo "$0: error: $*" >&2; exit 1; }
log()     { [ "$CMDDBG" ] && echo "[+ $*]" >&2; "$@"; }  # log without quotes
runline() { log eval "$1"; }


# POSIX compliant replacements for mkhelp.pl, mkfuncs.pl
# (the subshells are only used for local vars - 'local' isn't (yet) POSIX).

mkhelp() {
    echo "/* This file was generated by $0 from less.hlp at $(LC_ALL=C date -u) */"
    echo '#include "less.h"'
    echo
    echo 'constant char helpdata[] = {'

    # no need for dos2unix - it's displayed correctly even with \r\n EOLs
    od -b -v -A n |  # octal values, typically 16 per line
        awk '{ for(i=1; i<=NF; i++) printf("0%s,", $i); print "" }'

    echo '0 };'
    echo
    echo 'constant int size_helpdata = sizeof(helpdata) - 1;'
}

# TODO: use awk? we're quite slower than mkfuncs.pl (but not terrible - 1-2s)
mkfuncs() { (
    # for v490 or earlier (untested, mkfuncs.pl is used but missing)
    # printf "#ifndef LESSPARAMS\n#define LESSPARAMS LPARAM\n#endif\n\n"
    # printf "#ifndef VOID_PARAM\n#define VOID_PARAM void\n#endif\n\n"

    TAB=$(printf \\t) state=0 params=

    for file; do
        while IFS= read -r line; do
            case $state in
            0)  case $line in "${TAB}public"*) state=1 buf=${line#?}; esac;;
            1)  case $line in *"("*) state=2 buf="$buf ${line%%(*}"; esac;;
            2)  case $line in
                *";")   line=${line#"$TAB"}
                        params=$params${params:+, }${line%?}
                        ;;
                "{"*)   echo "$buf LESSPARAMS ((${params:-VOID_PARAM}));"
                        state=0 params=
                esac
            esac
        done < "$file"
    done
) }


# supported commands

cmd_del() { log rm -- "$@"; }

cmd_copy() { log cp -- "$@"; }

cmd_move() { log mv -- "$@"; }

cmd_if() {  # we identify only: (if) exist FILE CMD...
    [ "$1" = exist ] && [ $# -ge 3 ] || err "if: unknown form -- [$*]"
    if [ -e "$2" ]; then shift 2; log docmd -c "$*"; fi
}

cmd_perl() {  # CMDNOMK=1 skips the mk*.pl emulation
    case ${CMDNOMK:+x}$1 in
        mkfuncs.pl) shift; log mkfuncs "$@";;
         mkhelp.pl) shift; log mkhelp "$@";;
                 *) log perl "$@";;  # fallback, hopefully unreachable
    esac
}


# cmd.exe "interpreter"...
docmd() {
    [ $# = 2 ] && [ "$1" = -c ] || err "expecting [-c LINE] -- [$*]"

    # v622 (0c621952) replaced mkfuncs.pl with grep... | sed... >funcs.h
    # so identify the literal {pre,suf}fix, and just eval as is in sh
    case $2 in 'grep -h "^public'*'| sed "s/$/;/" >funcs.h'*)
        eval "$2"
        return
    esac

    # v645 (0e5bd36) has an alternative mkhelp.sh, which we can do as is
    case $2 in '(perl mkhelp.pl || sh mkhelp.sh)  < less.hlp  > help.c')
        eval "$2"
        return
    esac

    # v645 incremental Makefile.wng
    case $2 in 'comp /M funcs.h.tmp funcs.h || move funcs.h.tmp funcs.h')
        diff funcs.h.tmp funcs.h || mv funcs.h.tmp funcs.h
	return
    esac

    # allow wildcard/redirect, disallow quotes/lists/groups/escapes/vars
    case $2 in *[\''"\(){}|&;%$']*)
        err "command too complex -- [$2]"
    esac

    set -- "$2" $2  # $1 is the full line, $2... is split/blown

    case $2 in
    del|copy|move|if|perl)
        runline cmd_"$1";;
    gcc)
        runline "$1";;
    *)
        strstr " ${MAKEFLAGS-} " " CC=$2 " || err "unknown command -- [$1]"
        runline "$1"  # [cross-]compiler (make ... CC=FOO ...)
    esac
}

docmd "$@"
